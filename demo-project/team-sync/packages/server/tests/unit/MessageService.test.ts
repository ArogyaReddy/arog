/**
 * UNIT TESTS - MessageService
 * Generated by @arog for comprehensive test coverage
 */

import { MessageService } from '../../src/services/MessageService';
import { Message } from '../../src/types';

describe('MessageService', () => {
  let messageService: MessageService;

  beforeEach(() => {
    messageService = new MessageService();
  });

  describe('addMessage', () => {
    it('should add a new message to a room', () => {
      const messageData = {
        userId: 'user1',
        userName: 'John Doe',
        content: 'Hello, World!',
        roomId: 'room1',
        type: 'text' as const
      };

      const message = messageService.addMessage(messageData);

      expect(message).toMatchObject(messageData);
      expect(message.id).toBeDefined();
      expect(message.timestamp).toBeInstanceOf(Date);
    });

    it('should generate unique message IDs', () => {
      const msg1 = messageService.addMessage({
        userId: 'user1',
        userName: 'User 1',
        content: 'Message 1',
        roomId: 'room1',
        type: 'text'
      });

      const msg2 = messageService.addMessage({
        userId: 'user1',
        userName: 'User 1',
        content: 'Message 2',
        roomId: 'room1',
        type: 'text'
      });

      expect(msg1.id).not.toBe(msg2.id);
    });
  });

  describe('getMessagesByRoom', () => {
    it('should return all messages for a room', () => {
      messageService.addMessage({
        userId: 'user1',
        userName: 'User 1',
        content: 'Message 1',
        roomId: 'room1',
        type: 'text'
      });

      messageService.addMessage({
        userId: 'user2',
        userName: 'User 2',
        content: 'Message 2',
        roomId: 'room1',
        type: 'text'
      });

      const messages = messageService.getMessagesByRoom('room1');
      expect(messages).toHaveLength(2);
    });

    it('should return empty array for non-existent room', () => {
      const messages = messageService.getMessagesByRoom('non-existent');
      expect(messages).toEqual([]);
    });

    it('should not mix messages from different rooms', () => {
      messageService.addMessage({
        userId: 'user1',
        userName: 'User 1',
        content: 'Room 1 message',
        roomId: 'room1',
        type: 'text'
      });

      messageService.addMessage({
        userId: 'user1',
        userName: 'User 1',
        content: 'Room 2 message',
        roomId: 'room2',
        type: 'text'
      });

      const room1Messages = messageService.getMessagesByRoom('room1');
      const room2Messages = messageService.getMessagesByRoom('room2');

      expect(room1Messages).toHaveLength(1);
      expect(room2Messages).toHaveLength(1);
      expect(room1Messages[0].content).toBe('Room 1 message');
      expect(room2Messages[0].content).toBe('Room 2 message');
    });
  });

  describe('deleteMessage', () => {
    it('should delete a message successfully', () => {
      const message = messageService.addMessage({
        userId: 'user1',
        userName: 'User 1',
        content: 'To be deleted',
        roomId: 'room1',
        type: 'text'
      });

      const deleted = messageService.deleteMessage(message.id, 'room1');
      expect(deleted).toBe(true);

      const messages = messageService.getMessagesByRoom('room1');
      expect(messages).toHaveLength(0);
    });

    it('should return false for non-existent message', () => {
      const deleted = messageService.deleteMessage('non-existent', 'room1');
      expect(deleted).toBe(false);
    });

    it('should return false for wrong room', () => {
      const message = messageService.addMessage({
        userId: 'user1',
        userName: 'User 1',
        content: 'Message',
        roomId: 'room1',
        type: 'text'
      });

      const deleted = messageService.deleteMessage(message.id, 'wrong-room');
      expect(deleted).toBe(false);
    });
  });

  describe('getRecentMessages', () => {
    it('should return last N messages', () => {
      // Add 10 messages
      for (let i = 1; i <= 10; i++) {
        messageService.addMessage({
          userId: 'user1',
          userName: 'User 1',
          content: `Message ${i}`,
          roomId: 'room1',
          type: 'text'
        });
      }

      const recentMessages = messageService.getRecentMessages('room1', 5);
      expect(recentMessages).toHaveLength(5);
      expect(recentMessages[4].content).toBe('Message 10');
    });

    it('should default to 50 messages', () => {
      // Add 60 messages
      for (let i = 1; i <= 60; i++) {
        messageService.addMessage({
          userId: 'user1',
          userName: 'User 1',
          content: `Message ${i}`,
          roomId: 'room1',
          type: 'text'
        });
      }

      const recentMessages = messageService.getRecentMessages('room1');
      expect(recentMessages).toHaveLength(50);
    });
  });

  describe('searchMessages', () => {
    beforeEach(() => {
      messageService.addMessage({
        userId: 'user1',
        userName: 'User 1',
        content: 'Hello World',
        roomId: 'room1',
        type: 'text'
      });

      messageService.addMessage({
        userId: 'user1',
        userName: 'User 1',
        content: 'Testing search functionality',
        roomId: 'room1',
        type: 'text'
      });

      messageService.addMessage({
        userId: 'user1',
        userName: 'User 1',
        content: 'Another message',
        roomId: 'room1',
        type: 'text'
      });
    });

    it('should find messages matching query (case-insensitive)', () => {
      const results = messageService.searchMessages('room1', 'hello');
      expect(results).toHaveLength(1);
      expect(results[0].content).toBe('Hello World');
    });

    it('should return multiple matching messages', () => {
      const results = messageService.searchMessages('room1', 'message');
      expect(results).toHaveLength(1);
    });

    it('should return empty array when no matches', () => {
      const results = messageService.searchMessages('room1', 'nonexistent');
      expect(results).toEqual([]);
    });

    it('should be case-insensitive', () => {
      const results1 = messageService.searchMessages('room1', 'HELLO');
      const results2 = messageService.searchMessages('room1', 'hello');
      expect(results1).toEqual(results2);
    });
  });
});
